# 📌 文字編碼器 Text Encoder

自製的文字編碼器 Side Project，運用一些基本的密碼學原理，將輸入的文字加密編碼成不易破解的亂數密碼，同時也能夠即時將密碼解碼還原成原本的內容。

![Text Encoder Demo](https://user-images.githubusercontent.com/17502097/229436798-5becbe2d-c13e-4d1b-8cb8-2edb8e21ddc6.gif 'Text Encoder Demo')

## Demo

[https://waveciou-encoder.vercel.app](https://waveciou-encoder.vercel.app)

## 💡 從這個專案當中學到了什麼

- 基本的密碼學原理運用（凱薩密碼、替換式密碼）。
- 使用 [Vite](https://vitejs.dev/) 建立 [React](https://zh-hant.reactjs.org/) + [TypeScript](https://www.typescriptlang.org/) 開發環境。
- 使用 [Jest](https://jestjs.io/) 替每個執行的函式做單元測試（Unit Test）。
- 使用 [Netlify](https://www.netlify.com/) 作為專案部署的 Serverless 平台。

## 演算法說明

1. [字元轉換](#字元轉換)
2. [凱薩密碼](#凱薩密碼)
3. [亂數](#亂數)
4. [替換式密碼](#替換式密碼)

### 字元轉換

要製作一個文字編碼器，首先必須要將欲加密的字串明文（Plaintext）轉換成 unicode 代碼，接著利用一些加密演算法來進行加密的動作。

這邊可以使用 JavaScript 的 `String.prototype.charCodeAt()` 方法，將每個字元轉換為 0 至 65535 之間的整數。由於要使明文處理時有一致的規格，則必須要統一每個字元的長度，所以轉換後需要將未滿 5 位數的整數遞補 0。

```
12345 → '12345'
 5684 → '05684'
  456 → '00456'
```

### 凱薩密碼

這個編碼器的演算法主要是使用[凱薩密碼](https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC)（Caesar Cipher）來進行加密。凱薩密碼是古典密碼學中一種很常見的加密方式，他的概念是將有順序性的字符進行位移，進而產出密文（Ciphertext），藉此達成加密的效果。

假設欲加密的字串明文為「1、2、3、4、5」，可利用凱薩密碼位移的特性將明文轉換為「4、5、6、7、8」，此時的偏移量（Offset）為 3，若轉換後的數值大於 9，則會從 0 開始重新循環。

偏移量為 3 的狀況下，加密後的結果：

```
[1, 2, 3, 4, 5] → [4, 5, 6, 7, 8]
[0, 5, 6, 8, 4] → [3, 8, 9, 1, 7]
[0, 0, 4, 5, 6] → [3, 3, 7, 8, 9]
```

這個編碼器所運用的凱薩加密法除了基本的偏移量（Basic Offset）以外，還搭配了每個字元的索引數（Index）來計算，使每個位數的偏移量有所不同，進而增加密文的熵值。

```
字元的偏移量 = 基本偏移量 * (字元的索引數 + 1)
```

```
[1, 2, 3, 4, 5] + [3, 6, 9, 12, 15] = [4, 8, 2, 6, 0]
```

### 亂數

為了使每次編碼後能夠有不同的結果，演算法有加入亂數的機制，以增加加密時的複雜度。

使用亂數需要注意的是解碼時的運算邏輯，由於這個編碼器沒有後端 API 來配合使用，產生的密鑰也沒有寫入資料庫做儲存對照，加密機制是屬於單向式的「對稱式加密」，所以必須要把產生的亂數（這邊可以視為密鑰）隱藏在密文當中，以至於解碼時可以順利解碼。

這邊準備了一個含有 10 個數值的常數表，並從中亂數隨機選取一個公用常數來使用：

```
常數表 = [53, 97, 59, 89, 61, 83, 67, 79, 71, 73]
```

將公用常數乘上每個字元在字串中的索引數 mod 10 後 + 1，並將結果當作每個字元的基本偏移量。

```
基本偏移量 = 公用常數 * ((字元的索引數 mod 10) + 1)
```

接著把取得公用常數的索引數，添加在密文的最後一個字元，就完成了第一步驟的加密。

### 替換式密碼

[替換式密碼](https://zh.wikipedia.org/wiki/%E6%9B%BF%E6%8D%A2%E5%BC%8F%E5%AF%86%E7%A0%81)（Substitution Cipher）的概念是將明文字元以不同的符號去做替換，藉此達成加密的效果。

在加密的過程中最重要的是加密時所需要的**對照表（Table）**，明文依照對照表的內容替換成相對應的密文，只使用一張對照表的加密法稱為「單表替換加密」，使用多張對照表則稱為「多表替換加密」，這個編碼器主要是使用「多表替換加密」來完成最後的加密步驟。

這邊準備了 62 張對照表來進行替換式加密，首先先從 62 張對照表當中隨機取得一張來做為替換的標準依據，並將數值密文以每 2 個字元單位來進行替換，最後再將替換表的代號添加在密文的最後一個字元，就完成了最後的加密。

```
明文 = 1265846523452
替換表 (G) = [a:33, b:65, c:34, d:23]
密文 = 12b84bd452G
```

## 執行流程

假設要加密「編碼器」這組字串，首先必須要先把這三個字元分別轉換成對應的 unicode 代碼。

```
明文 = 編碼器

編 → 32232
碼 → 30908
器 → 22120
```

接著從準備好的常數表當中隨機取得一個公用常數來使用，假設隨機取得的數值為「4」，則使用常數表當中索引數為「4」的常數來使用，可以得知公用常數為「61」。

只要擁有常數表與索引數，就可以推測出公用常數是多少。

```
常數表 = [53, 97, 59, 89, 61, 83, 67, 79, 71, 73]
亂數 = 4
公用常數 = 61
```

接著要計算每個字元的基本偏移量，這邊使用設計好的偏移量公式來計算。

```
編 → 61 * ((0 mod 10) + 1) = 61
碼 → 61 * ((1 mod 10) + 1) = 122
器 → 61 * ((2 mod 10) + 1) = 183
```

之後再將每個字元的 unicode 代碼分別去做處理，並計算出最後的偏移量。

```
((0 mod 10) + 1) * 61 = 61
((1 mod 10) + 1) * 61 = 122
((2 mod 10) + 1) * 61 = 183
((3 mod 10) + 1) * 61 = 244
((4 mod 10) + 1) * 61 = 305

((0 mod 10) + 1) * 122 = 122
((1 mod 10) + 1) * 122 = 244
((2 mod 10) + 1) * 122 = 366
((3 mod 10) + 1) * 122 = 488
((4 mod 10) + 1) * 122 = 610

((0 mod 10) + 1) * 183 = 183
((1 mod 10) + 1) * 183 = 366
((2 mod 10) + 1) * 183 = 549
((3 mod 10) + 1) * 183 = 732
((4 mod 10) + 1) * 183 = 915
```

最後將明文依照偏移量來進行凱薩密碼轉換：

```
編：[3, 2, 2, 3, 2] + [ 61, 122, 183, 244, 305] = [4, 4, 5, 7, 7]
碼：[3, 0, 9, 0, 8] + [122, 244, 366, 488, 610] = [5, 4, 5, 8, 8]
器：[2, 2, 1, 2, 0] + [183, 366, 549, 732, 915] = [5, 8, 0, 4, 5]

密文 = 44577 + 54588 + 58045
```

為了使解碼時能夠有對照的依據，需要把取得公用常數用的亂數（密鑰）添加在密文的最後一個字元。

```
密文 = 445775458858045 + 4
```

接著來做替換式加密，首先需要先隨機取得一張替換表。

這邊總共會有 62 張替換表，分別代號為「a ~ z + A ~ Z + 0 ~ 9」，假設隨機取得的是代號為「a」的對照表。

```
table(a) = [ a:82, b:62, c:02, d:04, e:26, f:35, g:44, h:19, i:38, j:15, k:05, l:99, m:57, n:07, o:85, p:98, q:18, r:95, s:92, t:93, u:73, v:28, w:52, x:84, y:24, z:41, A:58, B:00, C:67, D:65, E:81, F:11, G:94, H:06, I:36, J:30, K:40, L:13, M:25, N:42, O:39, P:29, Q:21, R:54, S:08, T:61, U:20, V:75, W:31, X:68, Y:96, Z:46 ]
```

接著將欲加密的代碼以每 2 個字元為單位來進行替換，最後再將替換表的代號（密鑰）添加在密文最後一個字元。

```
4457754588580454 → gmV4588AdR + a
```

這邊順利將「編碼器」加密成「gmV4588AdRa」這組密文，只要知道密鑰所隱藏的位置，以及擁有對應的對照表、常數表，就可以將此密碼解碼還原成原本的明文。

```
密文 = gmV4588AdRa
```

透過這種方式來加密文字內容，若不知道規則且無法取得常數表與對照表，則很難進行破解。由於過程中也有使用到亂數來增添複雜度，可使得每組字串擁有 620 種編碼結果，以增加破解的困難度。

## License

[MIT](https://github.com/waveciou/Encoder/blob/master/LICENSE.md)
