# 📌 文字編碼器 Text Encoder

[Demo](https://waveciou.github.io/text-encoder/)

自製的文字編碼器 Side Project，運用一些基本的密碼學原理，將輸入的文字加密編碼成不易破解的密文亂碼，同時也可以將密文解碼還原成原本的內容。

![Text Encoder Demo](https://waveciou.github.io/text-encoder/img/demo.gif "Text Encoder Demo")

以下為這個 Side Project 的演算法說明：

## 目錄

- [字符轉換](#字符轉換)
- [凱薩密碼](#凱薩密碼)
- [亂數](#亂數)
- [替換式密碼](#替換式密碼)
- [💡 實際應用範例](#實際應用範例)

## 字符轉換

要製作一個文字編碼器，第一步必須要先將欲加密的字串明文（Plaintext）轉換成 unicode 代碼，接著再利用加密演算法來進行加密的動作。

可以使用 JavaScript 的 `String.prototype.charCodeAt()` 方法，將每個字符轉換為 0 至 65535 之間的整數。由於要使明文處理有一致的規格，則必須要統一字符的長度，所以轉換後需要將未滿 5 位數的整數遞補 0。

將字符轉換成 unicode 代碼，若轉換後的整數未滿 5 位數，則必須要遞補 0：

```
12345 → '12345'
 5684 → '05684'
  456 → '00456'
```

## 凱薩密碼

Text Encoder 的演算法主要是使用[凱薩密碼](https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC)（Caesar Cipher）來進行加密。凱薩密碼是古典密碼學中一種很常見的加密方式，他的概念是將有順序性的字符進行位移，進而產出密文（Ciphertext），達成加密的效果。

**將有順序性的字符進行位移，從而達成加密的效果**

假設欲加密的字串明文為 1、2、3、4、5，可利用凱薩密碼位移的特性將明文轉換為 4、5、6、7、8，此時的偏移量（Offset）為 3，若轉換後的數字大於 9，則會從 0 開始重新循環。

偏移量為 3 的狀況下，加密後的結果：

```
[1, 2, 3, 4, 5] → [4, 5, 6, 7, 8]
[0, 5, 6, 8, 4] → [3, 8, 9, 1, 7]
[0, 0, 4, 5, 6] → [3, 3, 7, 8, 9]
```

Text Encoder 所運用的凱薩加密法除了基本的偏移量（Basic Offset）以外，還搭配了每個字符的索引數（Index）來計算，使每個位數的偏移量有所不同，進而增加密文的熵值。

```
字符的偏移量 = 基本偏移量 * (字符的索引數 + 1)
```

```
[1, 2, 3, 4, 5] + [3, 6, 9, 12, 15] = [4, 8, 2, 6, 0]
```

## 亂數

為了使每次編碼後能夠有不同的結果，Text Encoder 的演算法有加入亂數的機制，以增加加密時的複雜度。

使用亂數需要注意的是解碼時的運算邏輯，由於這個 Side Project 沒有後端 API 來配合使用，產生的結果也沒有進資料庫做儲存對照，加密機制是屬於單向式的「非對稱式加密」，所以必須要把產生的亂數（這邊可以視為金鑰）隱藏在密文當中，以至於解碼時可以順利解碼。

這邊準備了一個含有 10 個數字的常數表，並從中亂數隨機選取一個公用常數來使用：

```
常數表 = [53, 97, 59, 89, 61, 83, 67, 79, 71, 73]
```

將公用常數乘上每個字符在字串中的索引數 mod 10 後 + 1，並將結果當作每個字符的基本偏移量。

```
基本偏移量 = 公用常數 * ((字符的索引數 mod 10) + 1)
```

接著把取得公用常數的索引數，添加在密文的最後一個字符，就完成了第一步驟的加密。

## 替換式密碼

[替換式密碼](https://zh.wikipedia.org/wiki/%E6%9B%BF%E6%8D%A2%E5%BC%8F%E5%AF%86%E7%A0%81)的概念是將明文以不同字母去做替換，藉此達成加密的效果。

在加密的過程中最重要的是加密所需要的**對照表（Table）**，明文依照對照表的內容替換成相對應的密文，只使用一張對照表的加密法稱為「單表替換加密」，使用多張對照表則稱為「多表替換加密」，Text Encoder 主要是使用「多表替換加密」來完成最後的加密步驟。

這邊準備了 62 張對照表來進行替換式加密，首先先從 62 張對照表中隨機取得一張來做為替換依據，並將數字密文以每 2 個字母單位來進行替換，最後再將替換表的代號添加在密文的最後一個字符，就完成了最後的加密。

```
明文 = 1265846523452
替換表 (G) = [a:33, b:65, c:34, d:23]
密文 = 12b84bd452G
```

## 實際應用範例

假設要加密「編碼器」這組字串，首先必須要先把這三個字符分別轉換成 unicode 代碼。

```
明文 = 編碼器

編 → 32232
碼 → 30908
器 → 22120
```

接著從準備好的常數表當中隨機取得一個公用常數來使用，假設隨機取得的數字為「4」，則使用常數表當中索引數為「4」的數來使用，可以得知公用常數是「61」。

只要保留常數表與索引數，就可以推測出公用常數是多少。

```
常數表 = [53, 97, 59, 89, 61, 83, 67, 79, 71, 73]
亂數 = 4
公用常數 = 61
```

接著要計算每個字符的基本偏移量，這邊使用設計好的偏移量公式來計算。

```
編 → 61 * ((0 mod 10) + 1) = 61
碼 → 61 * ((1 mod 10) + 1) = 122
器 → 61 * ((2 mod 10) + 1) = 183
```

之後再將每個字符的 unicode 代碼分別去處理，並計算出最後的偏移量。

```
((0 mod 10) + 1) * 61 = 61
((1 mod 10) + 1) * 61 = 122
((2 mod 10) + 1) * 61 = 183
((3 mod 10) + 1) * 61 = 244
((4 mod 10) + 1) * 61 = 305

((0 mod 10) + 1) * 122 = 122
((1 mod 10) + 1) * 122 = 244
((2 mod 10) + 1) * 122 = 366
((3 mod 10) + 1) * 122 = 488
((4 mod 10) + 1) * 122 = 610

((0 mod 10) + 1) * 183 = 183
((1 mod 10) + 1) * 183 = 366
((2 mod 10) + 1) * 183 = 549
((3 mod 10) + 1) * 183 = 732
((4 mod 10) + 1) * 183 = 915
```

最後將明文依照偏移量來進行凱薩密碼轉換：

```
編：[3, 2, 2, 3, 2] + [ 61, 122, 183, 244, 305] = [4, 4, 5, 7, 7]
碼：[3, 0, 9, 0, 8] + [122, 244, 366, 488, 610] = [5, 4, 5, 8, 8]
器：[2, 2, 1, 2, 0] + [183, 366, 549, 732, 915] = [5, 8, 0, 4, 5]

密文 = 44577 + 54588 + 58045
```

為了解碼時能夠有對照依據，需要把取得公用常數用的亂數（金鑰）添加在密文的最後一個字符。

```
密文 = 445775458858045 + 4
```

接下來來做替換式加密，首先需要先隨機取得一張替換表。

總共會有 62 張替換表，分別代號為「a ~ z + A ~ Z + 0 ~ 9」，假設隨機取得的是代號為「a」的對照表。

```
table(a) = [ a:82, b:62, c:02, d:04, e:26, f:35, g:44, h:19, i:38, j:15, k:05, l:99, m:57, n:07, o:85, p:98, q:18, r:95, s:92, t:93, u:73, v:28, w:52, x:84, y:24, z:41, A:58, B:00, C:67, D:65, E:81, F:11, G:94, H:06, I:36, J:30, K:40, L:13, M:25, N:42, O:39, P:29, Q:21, R:54, S:08, T:61, U:20, V:75, W:31, X:68, Y:96, Z:46 ]
```

接著將欲加密的代碼以每 2 個字母單位來進行替換，最後再將替換表代號（金鑰）添加在密文最後一個字符。

```
4457754588580454 → gmV4588AdR + a
```

最後順利將「編碼器」加密成「gmV4588AdRa」這組密文，只要知道金鑰所隱藏的位置，以及對應的對照表、常數表，就可以解碼還原成原本的明文。

```
密文 = gmV4588AdRa
```

透過這種方式來加密文字內容，若不知道規則且無法取得常數表與對照表，則很難進行破解。由於過程中也有使用到亂數來增添複雜度，可使得每組字串擁有 620 種編碼結果，以增加破解的困難度。
